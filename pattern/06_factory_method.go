package pattern

import "fmt"

/*
	Реализовать паттерн «фабричный метод».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Factory_method_pattern
*/


/*
Фабричный метод - пораждающий паттерн, который решает проблему создания различных продуктов,
без указания конкретных типов продуктов

Плюсы:
+ Избавляет тип от привязки к конкретным типам продуктов
+ Код производства продуктов можно переместить в одно место упрощая его поддержку
+ Проще добавлять новые продукты в программу
+ Реализует принцип открытости/закрытости

Минусы:
- Может привести к увеличению кода из-за создания параллельной иерархии типов. Так-как для каждого нового
класса продукта, нужно создать новый подкласс создателя.
*/

//пример использования паттерна Фабричный метод (в go реализуется частично в виде "Простая фабрика")
func exampleFactory()  {
	salad, _ := kitchen("салат")
	pizza, _ := kitchen("пицца")

	salad.taste()
	pizza.taste()
}

//общий интерфейс для возвращаемых фабричными методами типов
type iFood interface{
	taste()
}

//возвращаемые объекты реализующие общий интерфейс
type foods struct {
	name string
}
func (f *foods) taste()  {
	fmt.Printf("%s - это вкусно!", f.name)
}

type salad struct{
	foods
}
//создаваемый продукт салат
func newSalad() iFood  {
	return &salad{
		foods: foods{name: "салат"},
	}
}
//создаваемый продукт пицца
type pizza struct{
	foods
}
func newPizza() iFood  {
	return &pizza{
		foods: foods{name: "пицца"},
	}
}

//фабрика
func kitchen(foodType string) (iFood, error)  {
	if foodType == "салат"{
		return newSalad(), nil
	}

	if foodType == "пицца"{
		return newPizza(), nil
	}

	return nil, fmt.Errorf("%s, такой тип блюда мы готовить не умеем", foodType)
}


